
/* Copyright (c) 2010, Peter Barrett  
**  
** Permission to use, copy, modify, and/or distribute this software for  
** any purpose with or without fee is hereby granted, provided that the  
** above copyright notice and this permission notice appear in all copies.  
**  
** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
** SOFTWARE.  
*/

#include "Platform.h"
#include "LCD.h"

extern const byte Verdana_font_11[] PROGMEM;
const byte Verdana_font_11[] = {
    0,   // format
    11,   // fontHeight
    9,   // ascent
    33,   // from
    95,   // count
    59,   // totalWidth/8
    0x00,0x01,0x00,0x04,0x00,0x0B,0x00,0x10,0x00,0x1A,0x00,0x21,0x00,0x22,0x00,0x25,0x00,0x28,0x00,0x2D,0x00,0x34,0x00,0x36,0x00,0x39,0x00,0x3A,0x00,0x3F,0x00,0x44,0x00,0x49,0x00,0x4E,0x00,0x53,0x00,0x59,0x00,0x5E,0x00,0x63,0x00,0x68,0x00,0x6D,0x00,0x72,0x00,0x73,0x00,0x75,0x00,0x7B,0x00,0x82,0x00,0x88,0x00,0x8C,0x00,0x94,0x00,0x9A,0x00,0xA0,0x00,0xA7,0x00,0xAE,0x00,0xB3,0x00,0xB8,0x00,0xBF,0x00,0xC5,0x00,0xC8,0x00,0xCC,0x00,0xD2,0x00,0xD7,0x00,0xDE,0x00,0xE4,0x00,0xEB,0x00,0xF0,0x00,0xF7,0x00,0xFD,0x01,0x03,0x01,0x0A,0x01,0x10,0x01,0x16,0x01,0x1F,0x01,0x25,0x01,0x2C,0x01,0x32,0x01,0x35,0x01,0x3A,0x01,0x3D,0x01,0x44,0x01,0x4B,0x01,0x4D,0x01,0x52,0x01,0x57,0x01,0x5C,0x01,0x61,0x01,0x66,0x01,0x6A,0x01,0x6F,0x01,0x74,0x01,0x75,0x01,0x78,0x01,0x7D,0x01,0x7E,0x01,0x87,0x01,0x8C,0x01,0x91,0x01,0x96,0x01,0x9B,0x01,0x9F,0x01,0xA3,0x01,0xA7,0x01,0xAC,0x01,0xB1,0x01,0xB8,0x01,0xBD,0x01,0xC2,0x01,0xC6,0x01,0xCB,0x01,0xCC,0x01,0xD1,0x01,0xD8,0x01,0xD8,    // Col ends
    0x50,0x04,0x00,0x00,0x4C,0x20,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x38,0x00,0x10,0x20,0x00,0x80,0xC1,0x09,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,    // Line 0
    0xD1,0x44,0x62,0x18,0x52,0xA8,0x00,0x02,0xE2,0x39,0xC1,0x7C,0xDF,0x73,0x80,0x00,0x00,0xE3,0xE3,0x3C,0x3D,0xF3,0xFF,0x3D,0x0F,0x78,0x61,0x8F,0x13,0x9E,0x39,0xE3,0xDF,0xE1,0x86,0x23,0x0C,0x1F,0xE4,0x08,0x80,0x08,0x20,0x00,0x81,0x01,0x00,0x84,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x92,0x00,    // Line 1
    0xD1,0x4F,0x92,0x24,0x52,0x70,0x80,0x05,0x1E,0x46,0x23,0x41,0x01,0x8C,0x40,0x00,0x00,0x14,0x13,0x22,0x43,0x0A,0x10,0x43,0x0A,0x18,0xA1,0x8F,0x14,0x51,0x45,0x14,0x22,0x21,0x86,0x23,0x0A,0x20,0x62,0x09,0x40,0x00,0x20,0x00,0x81,0x01,0x00,0x84,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x92,0x00,    // Line 2
    0x87,0xF4,0x94,0x24,0x21,0xA8,0x80,0x05,0x12,0x04,0x25,0x42,0x02,0x8C,0x68,0x60,0x30,0x19,0xD4,0xA2,0x81,0x06,0x10,0x81,0x0A,0x19,0x21,0x56,0x98,0x31,0x83,0x14,0x02,0x21,0x85,0x54,0x91,0x40,0xA2,0x0A,0x20,0x03,0xBC,0xE7,0xBB,0xDF,0xEB,0x8F,0xDD,0xE7,0x79,0xF6,0xFF,0x18,0xC9,0x8C,0x7C,0x92,0x00,    // Line 3
    0x82,0x94,0x64,0x19,0x21,0x20,0x80,0x09,0x12,0x08,0xC9,0x7B,0xC2,0x74,0x69,0x9F,0xCC,0x2A,0x54,0xBE,0x81,0x07,0xFE,0x81,0xFA,0x1A,0x21,0x56,0x98,0x31,0x83,0x13,0x02,0x21,0x49,0x54,0x60,0x81,0x21,0x0C,0x10,0x00,0x63,0x18,0xC5,0x23,0x19,0x96,0x23,0x18,0xC6,0x39,0x09,0x18,0xC9,0x52,0x84,0x92,0x31,    // Line 4
    0x82,0x8E,0x09,0xA5,0x21,0x07,0xF3,0x89,0x12,0x10,0x31,0x06,0x24,0x8B,0xC6,0x00,0x03,0x4A,0x54,0xA1,0x81,0x06,0x10,0x8F,0x0A,0x1E,0x21,0x26,0x58,0x3E,0x83,0xE0,0xC2,0x21,0x49,0x54,0x60,0x82,0x21,0x08,0x00,0x03,0xE3,0x08,0xFD,0x23,0x19,0xA6,0x23,0x18,0xC6,0x31,0x89,0x15,0x55,0x22,0x8B,0x11,0xC9,    // Line 5
    0x8F,0xC5,0x0A,0x62,0x21,0x00,0x80,0x11,0x12,0x20,0x3F,0x86,0x24,0x88,0x41,0x9F,0xCC,0x4A,0x5F,0xE1,0x81,0x06,0x10,0x83,0x0A,0x19,0x21,0x26,0x58,0x30,0x83,0x20,0x22,0x21,0x49,0x54,0x90,0x84,0x20,0x88,0x00,0x04,0x63,0x08,0xC1,0x23,0x19,0xE6,0x23,0x18,0xC6,0x30,0x69,0x15,0x55,0x22,0x90,0x92,0x46,    // Line 6
    0x05,0x05,0x12,0x63,0x21,0x00,0x84,0x51,0x12,0x42,0x21,0x46,0x28,0x88,0xA8,0x60,0x30,0x09,0xA8,0x61,0x43,0x0A,0x10,0x43,0x0A,0x18,0xA1,0x06,0x34,0x50,0x45,0x14,0x22,0x21,0x30,0x89,0x08,0x88,0x20,0x88,0x00,0x04,0x63,0x18,0xC5,0x23,0x19,0x96,0x23,0x18,0xC6,0x30,0x29,0x12,0x22,0x51,0x20,0x92,0x00,    // Line 7
    0x85,0x1E,0x11,0x9C,0x92,0x00,0x84,0x60,0xEF,0xFD,0xC1,0x39,0xC8,0x73,0x28,0x00,0x00,0x44,0x08,0x7E,0x3D,0xF3,0xF0,0x3D,0x0F,0xE8,0x7F,0x06,0x33,0x90,0x39,0x0B,0xC2,0x1E,0x30,0x89,0x08,0x8F,0xE0,0x48,0x00,0x03,0xFC,0xE7,0xB9,0x1F,0x19,0x8E,0x23,0x17,0x79,0xF1,0xC6,0xF2,0x22,0x89,0x3C,0x92,0x00,    // Line 8
    0x00,0x04,0x00,0x00,0x12,0x00,0x04,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x48,0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x00,0x00,0x00,0x40,0x20,0x00,0x00,0x00,0x01,0x00,0x92,0x00,    // Line 9
    0x00,0x04,0x00,0x00,0x0C,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x0F,0xE0,0x00,0x00,0x00,0x1C,0x06,0x00,0x00,0x00,0x40,0x20,0x00,0x00,0x00,0x02,0x00,0x7C,0x00,    // Line 10
};

#if 0
extern const byte monofont[] PROGMEM;
const byte monofont[] = { // 5x10 (596 bytes)
	5,   // formatWidth - monospaced
    10,   // fontHeight
    8,   // ascent
    33,   // from
    94,   // count
    59,   // totalWidth/8

	0x02,0x80,0x00,0x00,0x82,0x40,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1D,0x07,0x00,0x00,0x04,0x00,0x10,0x1C,0x10,0x00,0x10,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x44,0x00,
	0x22,0x80,0x40,0x30,0x84,0x20,0x00,0x00,0x00,0x2E,0x23,0x9C,0x2F,0x9B,0xEE,0x70,0x00,0x00,0x01,0xCF,0x27,0x9D,0xCF,0xFD,0xD1,0x71,0xE3,0x08,0xE5,0xDE,0x77,0x9D,0xF8,0xC6,0x31,0x8F,0xD1,0x01,0x10,0x04,0x04,0x00,0x10,0x20,0x10,0x20,0x90,0x40,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x08,0x42,0x00,
	0x22,0x94,0xF4,0x48,0x88,0x11,0x08,0x00,0x00,0x51,0x64,0x62,0x68,0x20,0x31,0x88,0x00,0x10,0x42,0x30,0x24,0x63,0x28,0x42,0x31,0x20,0x65,0x08,0xE6,0x31,0x8C,0x62,0x48,0xC6,0xB1,0x88,0x50,0x81,0x28,0x02,0x04,0x00,0x10,0x20,0x10,0x00,0x10,0x40,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x08,0x42,0x00,
	0x20,0x3F,0x4A,0xC8,0x08,0x15,0x48,0x00,0x00,0x53,0x20,0x42,0xA8,0x40,0x51,0x89,0x08,0x6F,0xB0,0x36,0x54,0x61,0x18,0x42,0x11,0x20,0x69,0x0D,0xD6,0x31,0x8C,0x60,0x48,0xC6,0xAA,0x88,0x90,0x81,0x44,0x00,0x77,0x9E,0xF7,0x79,0xDE,0x61,0x92,0x4D,0x79,0xDE,0x7D,0x9E,0xE8,0xC6,0x31,0x8F,0xC8,0x42,0x00,
	0x20,0x14,0xE5,0x30,0x08,0x13,0xBE,0x0F,0x80,0x95,0x21,0x8D,0x2F,0x78,0x4E,0x78,0x01,0x80,0x0C,0x56,0x57,0xA1,0x1F,0x7A,0x7F,0x20,0x71,0x0D,0xD6,0x3E,0x8F,0x9C,0x48,0xAA,0xA4,0x71,0x10,0x41,0x00,0x00,0x0C,0x61,0x18,0xA2,0x31,0x20,0x94,0x4A,0xC6,0x31,0x8E,0x60,0x88,0xC6,0xAA,0x88,0x90,0x41,0x30,
	0x20,0x14,0x52,0xC8,0x08,0x15,0x48,0x00,0x00,0x99,0x22,0x03,0xF0,0xC4,0x91,0x08,0x00,0x6F,0xB0,0x97,0x74,0x61,0x18,0x42,0x31,0x20,0x69,0x0A,0xD6,0x30,0x8C,0x42,0x48,0xA9,0x4A,0x22,0x10,0x41,0x00,0x00,0x7C,0x61,0x1F,0xA2,0x31,0x20,0x98,0x4A,0xC6,0x31,0x8C,0x1C,0x88,0xAA,0xA4,0x89,0x08,0x42,0x4C,
	0x00,0x3F,0xE5,0x44,0x08,0x11,0x08,0x00,0x01,0x11,0x24,0x22,0x28,0xC4,0x91,0x11,0x08,0x10,0x40,0x10,0x8C,0x63,0x28,0x42,0x31,0x20,0x65,0x0A,0xCE,0x30,0x9C,0x62,0x48,0x91,0x51,0x24,0x10,0x21,0x00,0x00,0x8C,0x61,0x18,0x22,0x31,0x20,0x94,0x4A,0xC6,0x31,0x8C,0x02,0x88,0xA9,0x4A,0x8A,0x08,0x42,0x00,
	0x20,0x14,0x48,0xB8,0x04,0x20,0x00,0x40,0x11,0x0E,0x77,0xDC,0x27,0x39,0x0E,0x60,0x10,0x00,0x00,0x8F,0x8F,0x9D,0xCF,0xC1,0xF1,0x77,0xA3,0xF8,0xCD,0xD0,0x7C,0x5C,0x47,0x11,0x51,0x27,0xD0,0x21,0x00,0x00,0x7F,0x9E,0xF7,0xA1,0xF1,0x20,0x92,0x4A,0xC5,0xDE,0x7C,0x3C,0x77,0x91,0x51,0x7F,0xC8,0x42,0x00,
	0x00,0x00,0x00,0x00,0x02,0x40,0x00,0x80,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x17,0x03,0xE0,0x00,0x00,0x00,0x00,0x20,0x00,0x80,0x00,0x00,0x10,0x08,0x00,0x00,0x00,0x00,0x08,0x04,0x44,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x07,0x00,0x00,0x00,0x10,0x08,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,};
#endif

#ifdef pgm_read_byte
#define FNT(_x) pgm_read_byte(Verdana_font_11 + (_x))
//#define FNT(_x) pgm_read_byte(monofont + (_x))
#else
#define FNT(_x) Verdana_font_11[_x]
#endif

typedef void (*CharProc)(int x, int y, int width, int height, int color);

int DrawChar(int xx, int yy, int c, int color, CharProc proc = 0)
{
	if (proc == 0)
		proc = Graphics_::Rectangle;
    //byte* f = Verdana_font_11;
    if (c == 32)
        return FNT(1)>>2;  // Space is 1/4 font height (yuk);

    int i = c - FNT(3);
    if (i < 0 || i >= FNT(4)) return 0;

    int src = 0;
	int width = FNT(0);
	int height = FNT(1);
	if (width)
	{
		src = (6*8) + width*i;
	} else {
		int ci = 6 + i * 2;
		width = (FNT(ci) << 8) | FNT(ci + 1);   // simplify
		if (i > 0)
		{
			src = (FNT(ci - 2) << 8) | FNT(ci - 1);
			width -= src;
		}
		src += (6 + 2 * FNT(4)) * 8;    // start of pixels (roll into cols)
	}
    
    //  clip?
    byte mask = 0x80 >> (src & 7);  // Mask at start of line
    int end = (src+width) >> 3;     // number of bytes read
    src >>= 3;
    int makeup = FNT(5) - (end + 1 - src);
    for (byte y = 0; y < (byte)height; y++)
    {
        byte p = FNT(src++);
        byte m = mask;
        for (byte x = 0; x < (byte)width; x++)
        {
            if (p & m)
				proc(x+xx,y+yy,1,1,color);
               //Graphics_::SetPixel(x + xx, y + yy);
            m >>= 1;
            if (m == 0)
            {
                p = FNT(src++);
                if (p == 0 && (width-x) <= 8)   // early out
                    break;
                m = 0x80;
            }
        }
        src += makeup;
    }
    return width;
}

int MeasureChar(int c)
{
	if (FNT(0))
		return FNT(0);		// monospaced font
    if (c == 32)
        return FNT(1)>>2;  // Space is 1/4 font height (yuk);

    int i = c - FNT(3);
    if (i < 0 || i >= FNT(4)) return 0;

    int ci = 6 + i * 2;
    int width = (FNT(ci) << 8) | FNT(ci + 1);   // simplify
    int src = 0;
    if (i > 0)
    {
        src = (FNT(ci - 2) << 8) | FNT(ci - 1);
        width -= src;
    }
	return width;
}

//	Nasty Dot text drawing hack
#define DOTSCALE 2
typedef void (*CharProc)(int x, int y, int width, int height, int color);
int DrawChar(int xx, int yy, int c, CharProc proc);

static void DotProc(int x, int y, int width, int height, int color)
{
	x *= DOTSCALE*2;
	y *= DOTSCALE*2;
	Graphics_::Circle(x,y,DOTSCALE,color,true);
}

void DotDrawStr(const char* s, int len, int x, int y, int dotColor, bool erase, int bgColor)
{
	if (erase)
		Graphics_::Rectangle(x*DOTSCALE*2 - DOTSCALE,y*DOTSCALE*2 - DOTSCALE,len*DOTSCALE*2*7,DOTSCALE*2*10,bgColor);
	for (u8 i = 0; i < len; i++)
		x += DrawChar(x,y,s[i],dotColor,DotProc) + 1;
}

int Graphics_::Width()
{
	return LCD.Width();
}

int Graphics_::Height()
{
	return LCD.Height();
}

void Graphics_::OpenBounds()
{
	LCD.SetBounds(0,0,LCD.Width(),LCD.Height());
}

void Graphics_::SetBounds(int x, int y, int width, int height)
{
	LCD.SetBounds(x,y,width,height);
}

void Graphics_::Fill(int color, u32 count)
{
	LCD.Fill(color,count);
}

void Graphics_::Blit(const u8* data, u32 count)
{
	LCD.Blit(data,count);
}

void Graphics_::BlitIndexed(const u8* data, const u8* palette, u32 count)
{
	LCD.BlitIndexed(data,palette,count);
}

void Graphics_::Scroll(int y)
{
	LCD.Scroll(y);
}

void Graphics_::Direction(u8 rot, u8 dx, u8 dy)
{
	LCD.Direction(rot,dx,dy);
}

void Graphics_::Clear(int color)
{
	Rectangle(0,0,Width(),Height(),color);
	Scroll(0);
}

int Graphics_::MeasureString(const char* s, int len)
{
	int x = 0;
	while (len--)
		x += MeasureChar(*s++) + 1;
	return x;
}

int Graphics_::DrawString(const char* s, int len, int x, int y, int color)
{
    for (int i = 0; i < len; i++)
        x += DrawChar(x,y,s[i],color) + 1;
	return x;
}

int Graphics_::DrawString(const char* s, int x, int y, int color)
{
    return DrawString(s,strlen(s),x,y,color);
}

void Graphics_::Init()
{
    LCD.Init();
}

void Graphics_::Rectangle(int x, int y, int width, int height, int color)
{
	// Clip
    int right = x + width;
    int bottom = y + height;
    right = min(right,(int)Graphics.Width());
    bottom = min(bottom,(int)Graphics.Height());
    x = max(x,0);
    y = max(y,0);
    width = right - x;
    height = bottom - y;
    if (width <= 0 || height <= 0)
        return;
        
    LCD.SetBounds(x,y,width,height);
    LCD.Fill(color,(u32)width*height);
}

static void Draw4(int cx, int cy, int x, int y, int color)
{
	Graphics_::SetPixel(cx + x, cy + y,color);
	if (x != 0) Graphics_::SetPixel(cx - x, cy + y,color);
	if (y != 0) Graphics_::SetPixel(cx + x, cy - y,color);
	Graphics_::SetPixel(cx - x, cy - y,color);
}

static void Draw8(int cx, int cy, int x, int y, int color, bool fill)
{
	if (fill)
	{
		Graphics_::Rectangle(cx-y,cy-x,y<<1,1,color);
		Graphics_::Rectangle(cx-x,cy-y,x<<1,1,color);
		Graphics_::Rectangle(cx-x,cy+y,x<<1,1,color);
		Graphics_::Rectangle(cx-y,cy+x,y<<1,1,color);
	} else {
		Draw4(cx, cy, x, y, color);
		if (x != y)
			Draw4(cx, cy, y, x, color);
	}
}

//	Octant circle drawing
void Graphics_::Circle(int cx, int cy, int radius, int color, bool fill)
{
	int error = -radius;
	int x = radius;
	int y = 0;

//	draws in 4 strips from top down and middle up + reflection about y
	while (x >= y)
	{
		Draw8(cx, cy, x, y,color,fill);
		error += y;
		++y;
		error += y;
		if (error >= 0)
		{
			--x;
			error -= x<<1;
		}
	}
}

void Graphics_::SetPixel(int x, int y, int color)
{
	Graphics_::Rectangle(x,y,1,1,color);
}

bool cmp(const byte* d, const char* s)
{
    while (*s)
        if (*d++ != *s++)
            return false;
    return true;
}


//	FUSSY; needs cleanup
//  img2
//  0 width 32
//  4 height 32
//  8 format 8
//  9 reserved 8
//  10 colors 8
//  11 restartInterval 8
//  12 reserved 32
//  16 palette - restarts
//  TODO: backing up on repeated lines


void CheckStack(void* t, int len);
void Graphics_::DrawImage(File& f, int x, int y, int scroll, int lines)
{
	//File f;
	//char s[256];
	//sprintf(s,"Draw %d %d %d %d\n",x,y,scroll,lines);
	//print(s);

    Img2 hdr;    
    if (!f.Read(&hdr,sizeof(Img2)) || !cmp(hdr.sig,"img2"))
        return;
    
	//	Palettes are bad news on small machines
	//	Removing and replacing with new runlength format

    //  Load palette
   // byte palette[512];    
    int paletteLen = (hdr.colors*2 + 3) & ~3;
	f.Skip(paletteLen);   // Align to 4
    //f.Read(palette+2,paletteLen);   // Align to 4
    
    int width = hdr.width;
    if (lines == 0)
        lines = hdr.height;
    int maxy = min(hdr.height,lines) + y;
    
    //  Skip restart indexes
    if (hdr.restartInterval)
    {
        int restarts = (hdr.height + hdr.restartInterval - 1)/hdr.restartInterval + 1;
        if (scroll > 0)   // 
        {
            int i = min(scroll/hdr.restartInterval,restarts-1);
            scroll -= i*hdr.restartInterval;
            maxy -= i*hdr.restartInterval;
            f.Skip(i*4);
            ulong restart;
            f.Read(&restart,4);
            f.SetPos(restart);
        } else
            f.Skip(restarts*4);
    }
    
    //  Skip restart intervals
    if (maxy > 320)
        maxy = 320;
	LCD.SetBounds(x,y,hdr.width,maxy-y);    // TODO: clip
            
    byte format = hdr.format;
    if (format & 0x80)
    {
        f.SetPos(512 + ((long)scroll)*512);
        while (y < maxy)
        {
            // 512 bytes in buffer
            int count;
            const byte* b = f.GetBuffer(&count);
            LCD.Blit(b,width);
            f.Skip(512);
            y++;
        }
        return;
	}

	//	Other format deprecated because it was silly
}

u16 Graphics_::ToColor(u8 r, u8 g, u8 b)
{
	return TOCOLOR(r,g,b);
}